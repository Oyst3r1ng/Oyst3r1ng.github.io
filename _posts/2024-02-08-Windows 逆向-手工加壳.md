---
layout: mypost
title: "Windows 逆向-手工加壳"
categories: [Windows 逆向]
---

## 前言

如题，就是往程序里面加代码，然后实现一些小功能，演示的话就先从最简单MessageBox开始

## 课堂

### MessageBox介绍

MessageBox()函数：功能是弹出一个标准的Windows对话框；它不是C函数库的标准函数，而是一个API，我们可以用C语言调用API函数。可以理解成我们在C中使用MessageBox函数就表示调用系统提供的API函数–MessageBoxA。包含在头文件windows.h；如果一个程序中包含user32.dll，则此程序就有MessageBoxAAPI函数

```
int MessageBox( HWND hWnd,LPCTSTR lpText, LPCTSTR lpCaption = NULL, UINT nType = MB_OK );
```

四个参数说明：

```
hWnd：表示窗口句柄，指定该对话框的所有者窗口；如果该参数为空(0/NULL)，则该对话框不属于任何窗口
lpText：字符串，指显示在对话框中的内容
lpCaption：字符串，指对话框的标题；如果此参数为空，则默认使用“错误”作为标题
nType：指定显示按钮的数目及形式，表名使用的图标样式、缺省按钮是什么、以及消息框的强制回应等
```

### call与jmp指令的硬编码

- call指令的硬编码：**E8** 后面跟了4个字节(转换后的地址)

- jmp指令的硬编码：**E9** 后面跟了4个字节(转换后的地址)

由于call指令和jmp指令后面跟的是我们想要调用的函数地址或者跳转的地址，那E8和E9后面跟的4个字节是不是就是这个地址本身呢？不是！E8和E9后面跟的地址数据是需要转换得到的

下面举例说明：

```C
#include "stdafx.h"
void Function(int a,int b,int c,int d){    
}
int main(int argc,char* argv[]){
    Function(1,2,3,4);
    return 0;
}
```

![](image-53.png)

因为E8的当前地址为0x00401190，真正要跳转的Function函数的地址为0x00401014，根据公式：X = 要跳转的地址 - (E8的地址 + 该指令长度) = 0x00401014 - （0x00401190 + 5）= 0xFFFFFE7F，由于内存是低地址向高地址存储，所以为7F FE FF FF，所以最后call指令的硬编码为E8 7F FE FF FF

![](image-54.png)

### 给程序开头加个壳子

这个壳子就用MessageBox就行，我们没有必要自己去写，因为基本程序都有，这里还是拿everything来举例，为什么一直选它呢，第一个原因就是它在文件中和在内存中的对齐方式不一样，不像有的exe都是0x1000h，第二个原因就是它的imagebase不会乱跑，默认是啥就是啥，默认不会用到PIC

首先的话明确一下整体的思路，首先在程序中找一个MessageBox的函数，并记下地址，就用bp MessageBoxA这条指令就行，然后在代码段最后写上我们的硬编码，即传参和call到这个MessageBox的函数真正的地址上面，然后再写jmp去跳转的程序现有的OEP，最后把程序的OEP改成我们在代码段新添的代码的首地址，啊别听着简单，但做起来得超级细心才行

![](9D6B29F6B070AD0191737D0EC9AD8D0F-1024x691.jpg)

这个是找到的MessageBox的函数

![](image-55-1024x568.png)

然后咱们是在FileBuffer中加，咱们就到代码段最后面去加，因为代码段放到内存中也是不会变的，不存在有未初始化变量等的这种情况，这个怎么找，应该都会吧

![](Screenshot_1-4-1024x436.png)

然后就开始算哇，上面是算好的，其实就是算E8后面4个字节和E9后面四个字节，但真的得细心才行

说几个注意的点，第一是E8的地址是在ImageBuffer里面的地址，应该是用相对于相对于代码区.text开始地址的偏移量，再找.text节在内存中的起始地址（ImageBase + VirtualAddress），最后加起来，第二个就是OEP也是内存中相对于ImageBase的偏移地址，如果要从FileBuffer开始算的话，应该是先减去400h再加1000

然后再修改OEP

![](Screenshot_2-3-1024x667.png)

然后就可以保存楼，双击我们的程序看效果

![](Screenshot_3-1-1024x549.png)

可以看到咱们上面的操作其实都是在FileBuffer中做的，这么去写程序的话，必然会分成两种情况，就是文件和内存对齐尺寸一样的，还有就是文件和内存对齐尺寸不一样的，因为不一样的中间始终要做一个地址转换，那咱们为何不从Imagebuffer出发呢，因为咱们之前写过这个函数，这样的话就更方便了

总的来说这个过程是十分麻烦的，正在努力写程序ing，但这个程序不管怎么写都感觉有问题，当然直接加在代码段结尾的话这个程序没有问题，但是要写在其他段的话，程序不管咋设计都不太对劲，因为其他段的话会有未初始化的变量，由于咱们是模拟内存加载的过程，目前的话复制和粘贴段的大小都是SizeOfRawData，所以写在其它段必然要满足的一个条件就是misc必须小于SizeOfRawData，而且两者之差还得大于18个字节，也就是调用MessageBoxA所必须的18个字节，OK写完发

### 作业

写函数实现加壳子，努力写哇，下篇文章发