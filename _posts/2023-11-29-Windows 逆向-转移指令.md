---
layout: mypost
title: "Windows 逆向-转移指令"
categories: [Windows 逆向]
---

## 前言

这节课好好听，涉及到C语言中函数的知识了

## 课堂

### JMP

jmp指令的作用：**修改EIP的值**，且**jmp执行时只有eip发生变化**

EIP就是8086里面那个IP，**EIP中的地址值就是CPU要读取指令的地址**，但是jmp准确说没有跳转的作用，只是去修改EIP中的值，只有CPU才根据eip中的值去跳转，而且不是所有的指令都可以改EIP中的值，比如**mov指令没法对EIP做修改**

意思相当于：MOV EIP,寄存器/立即数   简写为   JMP 寄存器/立即数

### CALL

call作用：**修改EIP中的值**，**并且将call的下一跳指令的地址压入堆栈中**！所以栈顶地址也会发生变化，即**ESP会发生变化**，此地址也称**返回地址**

计算机是怎么知道下一跳指令的地址的：根据硬编码知识，不同的指令用编码表示有不同的字节，见下图。那么比如现在call指令的地址为0040116E，则在call执行之前，计算机就通过call的地址+call指令的硬编码长度5，把下一跳的地址算出来，并且将返回地址入栈

![](image-26.png)

### RETN

作用：**修改EIP中的值**，将栈顶地址中存的值—即**返回地址出栈**，并赋给EIP。因为要出栈，所以**esp的值会+4**，即栈顶指针下移

可以看作pop eip ，将现在栈顶中的值出栈赋给eip，CPU根据eip中的返回地址值跳转到原来call函数的下面

一般RET和CALL指令时成对出现的

### 额外介绍的两个指令，JCC会用到

- **CMP**

作用：**只改变标志寄存器**，不会修改任何一个操作数

原理：执行从目的操作数中**减去**源操作数的隐含减法操作（SUB），但是不对任何一个操作数做修改！只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1

格式：

```
CMP EAX,ECX
CMP AX,WORD PTR DS:[405000]   #可以将内存中的值与寄存器作比较，但是数据宽度必须一致
CMP EAX,DWORD PTR DS:[405000]
```

通过CMP执行后的标志寄存器来判断两个操作数的大小

![](image-27-1024x694.png)

- **TEST**

作用：该指令在一定程序上和CMP指令类似，两个数值**进行与AND操作**，**结果不保存**，**但是会改变相应标志位**

常见用法：一般用来判断某寄存器值是否为0（一般看**ZF**标志寄存器判断）

```
test eax,eax        #用来判断eax寄存器中值是否为0，如果为0，则最后ZF标志寄存器置为1
```

## JCC

```
1、	JE, JZ       		结果为零则跳转(相等时跳转)						ZF=1	
										
										
2、	JNE, JNZ        		结果不为零则跳转(不相等时跳转)  						ZF=0	
										
										
3、	JS 		结果为负则跳转						SF=1	
										
										
4、	JNS 		结果为非负则跳转						SF=0	
										
										
5、	JP, JPE   		结果中1的个数为偶数则跳转						PF=1	
										
										
6、	JNP, JPO   		结果中1的个数为偶数则跳转						PF=0	
										
										
7、	JO    		结果溢出了则跳转						OF=1	
										
										
8、	JNO    		结果没有溢出则跳转						OF=0	
										
										
9、	JB, JNAE   		小于则跳转 (无符号数)						CF=1	
										
										
10、	JNB, JAE    		大于等于则跳转 (无符号数)						CF=0	
										
										
11、	JBE, JNA    		小于等于则跳转 (无符号数)						CF=1 or ZF=1	
										
										
12、	JNBE, JA    		大于则跳转(无符号数)						CF=0 and ZF=0	
										
										
13、	JL, JNGE    		小于则跳转 (有符号数)						SF≠ OF	
										
										
14、	JNL, JGE    		大于等于则跳转 (有符号数)						SF=OF	
										
										
15、	JLE, JNG    		小于等于则跳转 (有符号数)						ZF=1 or SF≠ OF	
										
										
16、	JNLE, JG    		大于则跳转(有符号数)						ZF=0 and SF=OF	


注意：这个不需要背，用到的时候查就行
```

### 有无符号的区别

```
eax=0xffff0000;ecx=0x7ffffffff
cmp eax,ecx     #此时执行完后，当成无符号：CF=0，ZF=0，SF=0；当成有符号：OF=1

如果当成无符号的数，那么JA 0x00401139应该跳转，
①使用JA的文字条件判断：大于则跳转，eax确实比ecx大，所以跳转
②使用JA的条件判断：CF=0 and ZF=0，因为eax-ecx结果不等于0，且最高位没有发生借位，所以跳转

如果当成有符号的数，那么JG 0x00401129不跳转，
①使用JG文字条件判断：大于则跳转（有符号数）,因为当成有符号数，所以ecx表示正数，eax表示负数。而eax-ecx是负数减正数，不满足大于的情况，所以不跳转
②使用JG的条件判断：SF=OF and ZF=0，因为发生了溢出，所以OF=1，且结果不等于0，即ZF=0，所以不跳转
```

## 作业

![](image-28.png)

1.有变化，堆栈的栈顶地址-4，并且将call指令下一条指令的地址压栈；EIP的值为call函数后面跟的地址

![](image-29.png)

2.有变化，栈顶中的值出栈，将值赋给EIP，堆栈的栈顶地址+4

![](image-30.png)

3.......