---
layout: mypost
title: "Windows 逆向-转移指令"
categories: [Windows 逆向]
---

## 前言

这节课好好听，涉及到 C 语言中函数的知识了

## 课堂

### JMP

jmp 指令的作用：**修改 EIP 的值**，且**jmp 执行时只有 eip 发生变化**

EIP 就是 8086 里面那个 IP，**EIP 中的地址值就是 CPU 要读取指令的地址**，但是 jmp 准确说没有跳转的作用，只是去修改 EIP 中的值，只有 CPU 才根据 eip 中的值去跳转，而且不是所有的指令都可以改 EIP 中的值，比如**mov 指令没法对 EIP 做修改**

意思相当于：MOV EIP,寄存器/立即数    简写为    JMP 寄存器/立即数

### CALL

call 作用：**修改 EIP 中的值**，**并且将 call 的下一跳指令的地址压入堆栈中**！所以栈顶地址也会发生变化，即**ESP 会发生变化**，此地址也称**返回地址**

计算机是怎么知道下一跳指令的地址的：根据硬编码知识，不同的指令用编码表示有不同的字节，见下图。那么比如现在 call 指令的地址为 0040116E，则在 call 执行之前，计算机就通过 call 的地址+call 指令的硬编码长度 5，把下一跳的地址算出来，并且将返回地址入栈

![](image-26.png)

### RETN

作用：**修改 EIP 中的值**，将栈顶地址中存的值—即**返回地址出栈**，并赋给 EIP。因为要出栈，所以**esp 的值会+4**，即栈顶指针下移

可以看作 pop eip ，将现在栈顶中的值出栈赋给 eip，CPU 根据 eip 中的返回地址值跳转到原来 call 函数的下面

一般 RET 和 CALL 指令时成对出现的

### 额外介绍的两个指令，JCC 会用到

- **CMP**

作用：**只改变标志寄存器**，不会修改任何一个操作数

原理：执行从目的操作数中**减去**源操作数的隐含减法操作（SUB），但是不对任何一个操作数做修改！只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置 1

格式：

```
CMP EAX,ECX
CMP AX,WORD PTR DS:[405000]   #可以将内存中的值与寄存器作比较，但是数据宽度必须一致
CMP EAX,DWORD PTR DS:[405000]
```

通过 CMP 执行后的标志寄存器来判断两个操作数的大小

![](image-27-1024x694.png)

- **TEST**

作用：该指令在一定程序上和 CMP 指令类似，两个数值**进行与 AND 操作**，**结果不保存**，**但是会改变相应标志位**

常见用法：一般用来判断某寄存器值是否为 0（一般看**ZF**标志寄存器判断）

```
test eax,eax        #用来判断eax寄存器中值是否为0，如果为0，则最后ZF标志寄存器置为1
```

## JCC

```
1、	JE, JZ       		结果为零则跳转(相等时跳转)						ZF=1


2、	JNE, JNZ        		结果不为零则跳转(不相等时跳转)  						ZF=0


3、	JS 		结果为负则跳转						SF=1


4、	JNS 		结果为非负则跳转						SF=0


5、	JP, JPE   		结果中1的个数为偶数则跳转						PF=1


6、	JNP, JPO   		结果中1的个数为偶数则跳转						PF=0


7、	JO    		结果溢出了则跳转						OF=1


8、	JNO    		结果没有溢出则跳转						OF=0


9、	JB, JNAE   		小于则跳转 (无符号数)						CF=1


10、	JNB, JAE    		大于等于则跳转 (无符号数)						CF=0


11、	JBE, JNA    		小于等于则跳转 (无符号数)						CF=1 or ZF=1


12、	JNBE, JA    		大于则跳转(无符号数)						CF=0 and ZF=0


13、	JL, JNGE    		小于则跳转 (有符号数)						SF≠ OF


14、	JNL, JGE    		大于等于则跳转 (有符号数)						SF=OF


15、	JLE, JNG    		小于等于则跳转 (有符号数)						ZF=1 or SF≠ OF


16、	JNLE, JG    		大于则跳转(有符号数)						ZF=0 and SF=OF


注意：这个不需要背，用到的时候查就行
```

### 有无符号的区别

```
eax=0xffff0000;ecx=0x7ffffffff
cmp eax,ecx     #此时执行完后，当成无符号：CF=0，ZF=0，SF=0；当成有符号：OF=1

如果当成无符号的数，那么JA 0x00401139应该跳转，
①使用JA的文字条件判断：大于则跳转，eax确实比ecx大，所以跳转
②使用JA的条件判断：CF=0 and ZF=0，因为eax-ecx结果不等于0，且最高位没有发生借位，所以跳转

如果当成有符号的数，那么JG 0x00401129不跳转，
①使用JG文字条件判断：大于则跳转（有符号数）,因为当成有符号数，所以ecx表示正数，eax表示负数。而eax-ecx是负数减正数，不满足大于的情况，所以不跳转
②使用JG的条件判断：SF=OF and ZF=0，因为发生了溢出，所以OF=1，且结果不等于0，即ZF=0，所以不跳转
```

## 作业

![](image-28.png)

1.有变化，堆栈的栈顶地址-4，并且将 call 指令下一条指令的地址压栈；EIP 的值为 call 函数后面跟的地址

![](image-29.png)

2.有变化，栈顶中的值出栈，将值赋给 EIP，堆栈的栈顶地址+4

![](image-30.png)

3.......