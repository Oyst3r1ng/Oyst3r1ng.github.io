---
layout: mypost
title: "汇编语言之实验详解"
categories: [汇编语言]
---

> 你做三四月的事，在八九月自有答案
> 
> 人民日报

## 实验1 查看CPU和内存，用机器指令和汇编指令编程

如果要完成以后的学习任务或者是实验（本个实验也是需要的），那么debug是必不可少的，但是由于我们的电脑早已是64位或者是32位，而又不想去下载虚拟机的同学就可以在自己电脑上下这两个东西

链接：https://pan.baidu.com/s/1cODnmEBZZZJaPEQiRH9f\_w  
提取码：0786

链接已经给辣，里面有两个软件，打开就能用，就不多赘述了，然后有的小伙伴可能会担心自己会不会瞎改把自己的内存给搞坏，只能说在DOS时代，是可以的，但是也有内存界限的限制，比如操作系统那一块是不允许动的，而这个软件只是是win64/32底下模拟的一个16位环境，可以修改分配给这个程序的内存，所以完全不必担心哈，放心

* * *

- **然后第一题的话，题目就自己看吧，直接步入正题**

我们用A命令从1000:0开始写入汇编指令

![](Screenshot_115-1024x394.png)

用r cs和r ip改变CS:IP的指向

![](Screenshot_116-1024x365.png)

```
机器码				汇编指令					运行结果		CS:IP
b8 20 43			mov ax,4E20H			ax=4E20		1000:0003	
05 16 14			add ax,1416H			ax=6236		1000:0006
bb 00 20			mov bx,2000H			bx=2000		1000:0009
01 d8				add ax,bx				ax=8236		1000:000B
89 c3				mov bx,ax				bx=8236		1000:000D
01 d8				add ax,bx				ax=046C		1000:000F	
b8 1a 00			mov ax,001AH			ax=001A		1000:0012
bb 26 00			mov bx,0026H			bx=0026		1000:0015
00 d8				add al,bl				ax=0040		1000:0017
00 dc				add ah,bl				ax=2640		1000:0019
00 c7				add bh,al				bx=4026		1000:001B
b4 00				mov ah,0				ax=0040		1000:001D
00 d8				add al,bl				ax=0066		1000:001F
04 9c				add al,9cH              ax=0002	    1000:0021

```

上面就是一次次运行的具体情况

- **第二题**

![](image-1-1024x134.png)

用r cs和r ip改变CS:IP的指向

![](image-2-1024x159.png)

![](Screenshot_117-1024x634.png)

- **第三题还是挺有意思**

PC机主板上的ROM中写有一个生产日期，在内存FFF00H~FFFFFH的某几个单元中，请找到这个生产日期并改变它

![](Screenshot_104.png)

最终还是找到了，但要记住啊，这可是ROM，是只可以读而不能修改的

ROM是只读存储器（Read-Only Memory，ROM）以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器

- **第四题就涉及到显存辣**

```
e B810:0000 01 01 02 02 03 03 04 04
```

写这么一段数据到内存中

然后就出现了神奇的一幕

![](Screenshot_105.png)

之后回去看了一下这个地址空间，在8086中它确实是隶属于显存的地址空间，而且改变完这个地址空间的内容后确实是立即生效的，并没有用像CPU里面的寄存器去指向这个地址，感觉就是直接运行到了屏幕上面，这个一开始我是有点困惑，CPU按理来说是控制显存的，但现在这么看，好像对它放任不管了，接下来给个GPT的解释

![](Screenshot_119-1024x244.png)

![](Screenshot_118-1024x288.png)

* * *

## 实验2 用机器指令和汇编指令编程

- **第一题**

这个就还算是很简单哈，一步一步来就可以，接下来我把具体的每一步都截了图，大家可以对照指令和指令完成后的-r来一步步的查看

![](Screenshot_122.png)

![](Screenshot_123.png)

这里相信细心的小伙伴已经发现了问题了，是不是少了一条指令的执行，但是它的SP寄存器确实是发生了改变，这个会在后面的内容中讲到，目前我们只要记住这一点即可：Debug的T命令在执行修改寄存器SS的指令时，下一条指令也会紧接着被执行

![](Screenshot_124.png)

![](Screenshot_125.png)

![](Screenshot_126.png)

我这个是用的初始的CS与IP值，所以这道题的答案是不唯一的，仅供大家参考

```
mov ax,[0] ;ax=C0EAH

add ax,[2] ;ax=C0FCH

mov bx,[4] ;bx=30F0H

add bx,[6] ;bx=6021H

push ax ;sp=00FEH 修改的内存单元的地址是2200：FE到FF内容为：C0FCH

push bx ;sp=00FCH 修改的内存单元的地址是2200：FC到FD内容为：6021H

pop ax ;sp=00FEH ax=6021H

pop bx ;sp=0100H bx=C0FCH

push [4] ;sp=00FEH 修改的内存单元的地址是2200：FE到FF内容为：30F0H

push [6] ;sp=00FCH 修改的内存单元的地址是2200：FC到FD内容为：2F31H
```

- **第二题**

仔细观察图中的实验过程，然后分析：为什么2000:0~2000:F中的内容会发生改变？

![](Screenshot_130-1024x690.png)

可以看出这里面有cs值、ip值、ax值（这个容易看出来），我也是在不断学习，目前也只能看出这个，这里给出一个书上的后边的讲解，继续加油吧哈哈哈哈哈

```
中断过程P238
8086CPU在收到中断信息后，所引发的中断过程
（1）(从中断信息中)取得中断类型码
（2）标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)
（3）设置标志寄存器的第8位TF和第9位IF的值为0(这一步的目的后面将介绍)
（4）CS的内容入栈
（5）IP的内容入栈
（6）从内存地址为中断类型码4和中断类型码4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS
```

学到那部分之后，也会回来给出我自己的见解，那这个实验就到这里吧

* * *

持续更新中......