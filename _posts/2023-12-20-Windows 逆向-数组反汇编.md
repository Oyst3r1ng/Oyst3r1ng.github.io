---
layout: mypost
title: "Windows 逆向-数组反汇编"
categories: [Windows 逆向]
---

## 前言

这节课主要还是回顾了一下大一学过的数组，但是现在从汇编的角度看它，真的会有了不一样的感悟

## 课堂

### 数组的定义

一组相同类型的变量，为了方便读写，采用另外一种表示形式

```
/*void Function(){	
	int v_0 = 1;
	int v_1 = 2;
	int v_2 = 3;
	int v_3 = 4;
	int v_4 = 5;
	int v_5 = 6;
	int v_6 = 7;
	int v_7 = 8;
	int v_8 = 9;
	int v_9 = 10;
}*/
//使用数组表示
void Function(){					
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};	
}
```

注意：**在数组声明时，必须用常量来指明长度，不能使用变量**

```
void Func(){
	int x = 10;
	int arr[x] = {1,2,3,4,5,6,7,8,9,10};  //错误的！在数组声明时，必须用常量来指明长度（根据编译器版本决定是否可以，这里学的是不可以的）
}
```

这是为什么呢，咱们从反汇编的角度去分析一下

在函数提升堆栈的那一块，编译器提升堆栈时开辟的缓冲区大小默认为0x40字节，每有一个局部变量就增加4字节，我们定义的数组大小为10个元素，即等于10个局部变量，任意类型的局部变量都用32位容器存储，上一章提过，所以这里要开辟40h + 28h大小的缓冲区，但如果现在定义成int arr\[x\]的话，数组的长度就无法确定，那么编译器就无法提前给数组分配好内存，所以会报错

### 数组的使用

- 数组在使用时，可以通过常量、变量来定位数据

- 数组定位时，可以超过数组的长度，编译不会有错，但读取的数据是错的

```
void Function()	
{	
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
	
	int x = 1;
	int y = 2;
	int r ;
	
	r = arr[1];
	r = arr[x];
	r = arr[x+y];
	r = arr[x*2+y];
	r = arr[arr[1]+arr[2]];
	r = arr[Add(1,2)];
	int a5 = arr[100];  //不会报错
}
```

### 数组的反汇编

- 编译器会根据数组声明时指定的长度来开辟指定大小的空间，无论当中元素有没有赋初始值

- 数组元素存入缓冲区是正着存的，但是在栈中存的位置是从低地址向高地址存的，比如int arr\[3\] = {1,2,3};，先把1存入\[ebp-0xC\]，再将2存入\[ebp-8\]，最后把3存入\[ebp-4\]

![](image-45.png)

![](image-46.png)

## 作业

![](image-47.png)

2.数组是3个的时候esp也是提升了4个，数组是4个的时候也是提升了4个，只不过传3个，剩下有个int3，也就是CC；参数在传递的时候和32位架构保持一致，都是一次传4个字节，但是函数里面要使用参数的话，用的是自身的字节，比如char就还是只使用一个字节，局部变量和参数也是如此，这俩这方面也是一致的；以后定义参数以及局部变量的时候，就不要整什么char和short，因为在计算机中都是统一分配4个字节

计算机的步子就是32位，尤其堆栈这块都是4个4个字节来的，计算机只是在追求速度和追求空间中选择了追求速度

3.

- 因为Func函数中定义了13个局部变量，小于等于32位的任何类型的局部变量都会被分配32位内存来存储，所以VC6的编译器在提升堆栈时会开辟0x40 + 0x34h = 0x74字节的缓冲区

![](image-48.png)

- 接着分析定义局部变量和赋值的反汇编：还是正着存局部变量，现存x = 1到\[ebp - 4\]，再试y = 2到\[ebp - 8\]，接着是int r，此时r会被分配内存空间\[ebp - 0xC\]，但是没有赋值。接着就是存数组从1存到10，但是从低地址往高地址存，所以从\[ebp - 0x34\]每隔四个字节一直存到\[ebp - 0x10\]

![](image-49.png)

接着就开始分析如何根据下标找内存中数组元素：

- 如果是`arr[1]`直接可以通过\[ebp - 30h\]来找到，因为从低地址\[ebp - 34h\]到高地址\[ebp - 10h\]分别是arr\[0\]到arr\[9\]

![](image-50.png)

- 如果是r = arr\[x\];，x也是一个局部变量，所以先把x的值从\[ebp-4\]中取出来赋给一个寄存器ecx，然后因为arr\[0\]所在地址为\[ebp - 0x34\]，如果下标为1，则加一个0x4；如果下标为2，则加两个0x4。所以现在下标为寄存器ecx中存的值，那么就是\[ebp - 34h + ecx \* 4 \]

![](image-51.png)

- 如果是r = arr\[x+y\];，x和y都是局部变量，所以先把x的值从\[ebp - 4\]中取出来赋到一个寄存器eax中，同理也把y的值从\[ebp - 8\]中取出来与eax中的值相加后结果赋到寄存器eax中，那么arr\[x + y\]表示的地址即为\[ebp - 0x34 + eax \* 4\]，所以将\[ebp - 0x34 + eax \* 4\]内存中的值取出来赋到一个寄存器ecx中，最后将ecx中的值赋给局部变量r所在内存地址\[ebp - 0xC\]中即可

![](image-52.png)

- 如果是r = arr\[x\*2+y\];，这个要注意的是乘法编译器是如何翻译成汇编指令的？先将x,y的值从内存中以此取出存到edx和eax寄存器中，然后可以使用lea 寄存器,\[立即数\]的方式，直接将表达式edx \* 2 + eax放到\[\]中当做一个地址立即数，那么lea是直接将这个计算出来的立即数存入ecx中，而不会去找这个立即数做表示的内存地址编号中的存的值。所以ecx中存的就是x \* 2 + y的结果，再根据\[ebp - 0x34 + ecx \* 4\]找到这个下标所在的内存空间，最后将当中的值存到edx中，再存到r表示的内存地址\[ebp - 0xC\]中，这么看编译器还是有点聪明的哈哈哈哈哈

![](image-53.png)

4.桶排序

![](image-54-1024x640.png)

```
void sort_arry_tong(){

	int arry[10] = {3,4,6,2,1,6,6,7,0,4};
	int arry_none[10] = {0};
	int i = 0;

	for(i;i < 10 ;i++){
		
		int temp = 0;
		temp = arry[i];
		arry_none[temp]++;
	}
	
	int j = 0;
	for(j;j < 10;j++){
		
		int j_2 = 0;
		for(j_2;j_2 < arry_none[j];j_2++){
			printf("%d",j);
		}
	}
}
```

OKK结束睡觉