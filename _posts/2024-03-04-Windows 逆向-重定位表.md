---
layout: mypost
title: "Windows 逆向-重定位表"
categories: [Windows 逆向]
---

## 前言

这节课的话，就是得先很清楚的对整个exe程序加载到内存这个过程十分的清楚，明白为什么要去有重定位表，哪些情况（数据）要用到重定位表，以及对重定位表这个结构有很清晰的了解，最后再知道操作系统是怎么去根据这张表去做一个定位的，嗯嗯清楚以上我说的这些问题后，基本就差不多喽

## 课堂

### 引入（程序加载的过程）

每一个可执行程序运行都有一个独立的4GB虚拟内存（32位），地址从0x00000000到0xFFFFFFFF，低2G为用户程序空间、高2G为操作系统内核空间；且一个PE文件有很多个PE文件组成，如用OD打开`ipmsg.exe`文件

![](images/image-26-1024x313.png)

程序运行 --> 操作系统会给程序分4GB虚拟内存 --> 剩下的事情就像“拉伸贴图”一样（装载）

![](images/image-27-1024x692.png)

- **先装载自身的`.exe`**：如先把`ipmsg.exe`拉伸贴到ImageBase（0x00400000），分配空间大小为SizeOfImage（0x3D000）

```
但并不是所有文件的ImageBase都是0x400000，这个值是可以修改的：打开VC->右键你的项目->setting->选择Link->Category设置为Output->在Base address选项中就可以自定义ImageBase，之后这个程序编译以后，ImageBase就变了
```

- **再装载需要用到的`.dll`**：如把`ws2help.dll`拉伸贴到它的ImageBase（0x71A10000），分配空间大小为SizeofImage（0x8000）。其他`.dll`也是如此

- 最后把EIP指向EOP（AddressOfEntryPoint），这个程序就可以执行了

### 为什么要去有重定位表

听完上面的介绍，是不是觉得，出来这个一开始就加载进去的exe主程序位置可能不会被抢占，其他的Dll程序就像是那个python的线程一样，一起去抢位置，这样的话就会出现这样一个问题

默认情况下DLL的ImageBase为0x10000000，所以如果一个程序要用的DLL没有合理的修改分配装载起始地址，就可能出现多个DLL的ImageBase都是同一个地址，造成装载冲突

编译器的解决办法：如果一个DLL在装载时，发现其他DLL已经占用这块空间了，那么这个DLL会依据模块对齐粒度，往后找空余的空间存入，所以此时这个DLL的装载起始地址和它的ImageBase就不一致了（通俗讲叫"换位置"），我们知道RVA其实是个相对的值，只要我们把ImageBase改了，那就行了呗，但对于一些情况真的如此吗？一个`.dll`或`.exe`PE文件中的全局变量，可能在编译完成后，全局变量的地址就写死了，即它生成硬编码时地址值为：**ImageBase + RVA**；相当于编译完成后，这个全局变量的绝对内存地址就写入PE文件了，我们就不能通过单纯的改偏移去改了，下面举个例子

![](images/image-29-1024x542.png)

所以这些值是要去改变的，并不是说所有的值都要去改变

### 哪些情况（数据）要用到重定位表

![](images/image-30-1024x465.png)

嗯嗯上面就顺带说了

所以如果一个PE文件可能会出现“换位置”的情况，那么就需要重定位表，来记录下来，有哪些地方的数据需要做修改、重新定位，保证“换位置”后，操作系统能正确找到这些数据  
比如问题二中：这个PE文件也没有按照ImageBase去装载，那么全局变量a的存储地址就会发生变化，但是由于硬编码已经生成：A1 30 4A 42 00，那么重定位表就会把30 4A 42 00这个数据的地址记下来，等到运行时操作系统会根据重定位表找到这个数据，做一个重定位修改，即把0x00424a30这个绝对地址做修改，进行重定位，保证全局变量a可以被准确找到（修改的操作全程有操作系统负责）  
为什么很多.exe不提供重定位表，.dll会提供？因为一个PE文件的.exe一般只有一个，且是最先装载，所以装载位置和ImageBase是一致的，也没人跟它抢；但是.dll有很多，就需要考虑装载的位置不是预期的位置，那么这个.dll就需要提供重定位表

### 重定位表结构

![](images/image-31.png)

```C
struct _IMAGE_BASE_RELOCATION{
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
    //一堆数据...（如果是最后一个这种结构，就只有RVA和SizeOfBlock，且都为0）
};
```

它和之前学的那些表其实还不太一样

![](images/image-32.png)

可以这么理解：**一个重定位表中可能会有多个“块”**，每个块的结构都是①**4字节VirtualAddress**、接着②**4字节SizeOfBlock**、最后是③**一堆数据**。**每个块的大小为SizeOfBlock**

![](images/image-33-1024x633.png)

- 中间的那个SizeOfBlock大家肯定都能看懂，我这里就不解释，主要就是它和那个当前一共有多少个要修改的数据这块有关系

- 然后一开始的VirtualAddress和后面的一堆数据，打算一起来说

首先要知道模块，节，页这三者的概念，每一个Dll就是不同的模块，然后每一个模块里面都会有不一样的节，然后内存中还会分页，就是把每1000H个相邻的数据分成一页，这也是我们导出表为什么要这么设计的原理，现在来算个数学题，1000H用10进制表示的话就是4096

![](images/image-34.png)

而4096恰好是2的12次方（也就是从000000000000到111111111111），所以呢要是以每1000H为基准的话，其实12个0或1就能完全表示1000H所有的数，但是因为内存对齐，所以还是得用16个0或1去表示每1000H上面的数，但是前4位我们是不用的，一字节等于8比特，也就是两个字节WORD了，那前面这4个字节有什么用呢？高4位表示类型：值为3，代表低12位 + 该块的VirtualAddress地址处的数据需要修改做重定位；值为0，代表这2字节数据用来做数据对齐（填充用的），可以不用修改

### 为什么要学重定位表

#### 破解方面

加密壳：如果想对一个程序加加密壳之前，需要先将程序的各种表—导出表，导入表，重定位表等移动到新增的节当中，移走后对剩下的数据加密（所有的头和节表不能加密！DOS头，NT头，节表）。为什么呢？因为我们知道这些表其实分散在程序的某个节当中，如果直接对整个程序的数据加密，那么最后操作系统也找不到各种表了，无法加载用到的各种DLL了（比如找不到导入表，那么操作系统进行装载时，无法知道有哪些DLL要装到虚拟内存中），所以程序就无法执行  
所以就需要对各种表非常熟悉，才知道从哪里移

#### 反调试

反调试：有些游戏公司为了避免别人调试，会在驱动层（0环）把很多函数加上钩子（hook），比如说有一个函数叫openprocess()，用来打开进程。而如果想调试任何进程，都需要先打开进程，像使用OD–>点击附加，本质上就是使用了0环的openprocess()这个函数，那么由于游戏公司给这个函数加上了钩子，在调用这个函数时，游戏就会判断这个函数的参数是否是游戏进程本身，是的话就返回一个0（NULL），不让别人看到它。所以使用OD点击附加–>找进程打开时，会发现游戏的进程根本不在这里面  
反反调试：即过游戏驱动，一个比较常用的方式叫----内核重载，即把内核程序（0环）kernel.exe拉伸，把拉伸后的数据往内存中复制一份，只不过这个程序是0环的程序，用的是0环的语法，不能像我们平时在3环写程序用的语法。但是现在不允许把拉伸后的数据往内存复制，因为此时原来的kernel.exe已经把位置占着了，所以只能在它的后面一个模块中复制，这种情况不就和上文中的问题一一样，“换位置”了。那么这个程序中的所有绝对地址都不能用了，都必须自己根据重定位表把要修正的数据修正重定位。那么我们再想用程序就不用它提供的加过钩子的内核，而使用我们自己复制的这一份

## 作业

![](images/image-35.png)

之后再说吧，累了