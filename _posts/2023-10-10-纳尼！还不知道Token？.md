---
layout: mypost
title: "纳尼！还不知道Token？"
categories: [Web 安全]
---

- **前言**

又是熟悉的前言部分，这篇文章来讲一下啥是个 Token？这篇文章更多的是贴合网络安全里面的一些知识，比如和这些有关的 XSS 或者是 CSRF，XSRF，不是偏向于开发如何写个 Token 的代码，然后的话本篇会先给大家讲一下为什么要有这些东西，然后讲 Session 和 Cookie 吧，然后延伸到 Token 以至 JWT！先让大家对于本篇文章的架构有个基本的了解

![](image-22.png)

- **认证**

首先来介绍一下什么是 HTTP

```
HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。
```

但是呢，这个 HTTP 协议是无状态的协议，说明它不能以状态来区分和管理请求和响应；也就是说，服务器单从网络连接上无从知道客户身份，要是 HTTP 这个协议是点对点的那就不会有这个认证方面的问题，但 HTTP 是多对多的，或者说一个时间段，很多台计算机同时访问一台服务器，那么这怎么去区分呢？如果不去区分的话，是不是就完全混乱了呢？比如说服务器想给客户端去返回数据的时候，是不是就找不到这个数据应该给哪一个客户端了呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证，这样就引出了咱们的 Cookie！

![](image-13.png)

- **Cookie**

  1.Cookie 翻译过来是‘小甜饼’，Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上 Cookie 是服务器在本地机器上存储的一小段文本(不要认为它是一种像 json 一样的数据传输格式，大家就把它理解成是你浏览器的一部分，发请求的时候就会自动去带这个 Cookie)，并随着每次请求发送到服务器，而且这个 Cookie 是会携带用户的标志信息的

  2.Cookie 技术通过请求和响应报文中写入 Cookie 信息来控制客户端的状态  
  Cookie 会根据响应报文里的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie,当下客户端再向服务端发起请求时，客户端会自动在请求报文中加入 Cookie 值之后发送出去

之后服务端发现客户端发送过来的 Cookie 后，会检查是那个客户端发送过来的请求，然后对服务器上的记录，最后得到了之前的状态信息

![](image-14.png)

客户端保存了 Cookie 之后的发起请求

![](image-15.png)

![](image-16.png)

上图很清晰地展示了发生 Cookie 交互的情景，HTTP 请求报文和响应报文的内容如图所示

第一可以很明显的可出首部字段内没有 Cookie 的相关信息，其次也能看到 set-Cookie 里的信息，这就是服务器端生成的 Cookie 信息

![](image-17.png)

看之后请求，请求报文里都自动发送 Cookie 信息了

3.然后再来说一下这个 set-Cookie 字段的属性，以及由这个点来带大家看一下这个 HttpOnly 的属性到底是怎么来的，先给大家看一下 set-Cookie 的字段

```
Set-Cookie: logcookie=3qjj; expires=Wed, 13-Mar-2019 12:08:53 GMT; Max-Age=31536000; path=/;
 domain=fafa.com;secure; HttpOnly;
```

就上面这个例子，给大家说明一下

```
1.logcookie=3qjj 赋予Cookie的名称和值，logcookie是名字 ，3qjj是值
2.expires 是设置cookie有效期。当省略expires属性时，Cookie仅在关闭浏览器之前有效。可以通过覆盖已过期的Cookie，设置这个Cookie的过期时间是过去的时间，实现对客户端Cookie 的实质性删除操作
3.path 是限制指定Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待
4.domain 通过domain属性指定的域名可以做到与结尾匹配一致。比如，指定domain是fafa.com，除fafa.com那么www.fafa.com等都可以发送Cookie
5.secure 设置web页面只有在HTTPS安全连接时，才可以发送Cookie。HHTP则不可以进行回收
6.HttpOnly 它使JavaScript 脚本无法获得Cookie，通过上述设置，通常从Web 页面内还可以对Cookie 进行读取操作，但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了
，大家在学xss的时候，肯要防御xss肯定听过这个HttpOnly，那么这个的实现就是靠这个的
```

- **session**

  1.session 的话就是将用户的这些特征值，都放到了服务器端，然后每生成一个 session 就会生成 session 的 id 值，这个 id 值会发送给客户端，具体的发送模式有好多种，下面举几个例子

```
1.在响应的HTML中插入令牌：服务器可以将生成的 CSRF 令牌嵌入到生成的 HTML 页面中，以便浏览器在加载页面时接收到令牌。这通常通过在表单中添加一个隐藏字段来实现。
2.在响应的Cookie中设置令牌：服务器可以将 CSRF 令牌存储在 Cookie 中，并在响应中将其发送到浏览器。浏览器会自动将该 Cookie 存储在客户端，并在每次请求中自动包括该 Cookie。这样，CSRF 令牌会随每个请求一起发送到服务器。
3.在响应的头部中设置令牌：服务器可以将 CSRF 令牌存储在响应的头部中，并在每次响应中发送到浏览器。然后，浏览器可以通过 JavaScript 代码将令牌提取出来，并在需要时将其包括在请求头中。
```

2.客户端每次请求都会把这个 id 值放到 http 请求的头部发送给服务端，而这个 id 值在客户端会保存下来，保存的容器就是 cookie

因此当我们完全禁掉浏览器的 cookie 的时候，服务端的 session 也会不能正常使用，PHP 中的 Session 在默认情况下是使用客户端的 Cookie 来保存 Session ID 的，所以当客户端的 cookie 出现问题的时候就会影响 Session 了

必须注意的是：Session 不一定必须依赖 Cookie，这也是 Session 相比 Cookie 的高明之处。当客户端的 Cookie 被禁用或出现问题时，PHP 会自动把 Session ID 附着在 URL 中，这样再通过 Session ID 就能跨页使用 Session 变量了

![](image-18.png)

解释一下上面这个流程图

```
1.客户端把信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器
2.服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的信息进行验证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie 内写入Session ID（如PHPSESSID=l128ogl…）。你可以把Session ID 想象成一种用以区分不同用户的唯一Id。

3.客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 验证状态。
```

- **Cookie 和 Session 的区别**

  1.想必大家听完上述的讲解，也一定知道这俩名词的概念了，可能也明白其中的不同了，如果还没有悟到，下面给大家再解释一下

  2.企业的话，两种都会去用，只能说是各有好坏

```
1.cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的，但也可以剔除这种依赖，但大部分浏览器都是默认用Cookie去存储Session ID
2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session
，但其实想要攻击的话，谁有防不住
3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie

4.单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K
5.Session的话，对于分布式的一些网站程序，就是一个项目同时在多个服务器上跑，那么这个Session就还得解决在每个服务器上的Session都得保持一致的更新，或者专门去建一个有关于Session的服务器，然后去进行统一的管理
```

![](image-23-1024x1024.png)

- **正文-Token**

  1.之前之所以给大家去讲这些和 Token 没直接关系的东西，也是为了让大家去先更好的对数据包的传输以及认证去有个好的理解，然后再看这个 Token 就不会两眼发懵了，这里讲 Token 的话，我准备从这个 CSRF 攻击去入手，带大家去看一下 Token 为什么能够去防御 CSRF，以及 Token 是怎么来的，懂了这些的话，Token 是个啥，大家自己就悟了

  2.先给大家展示一个 CSRF 完整的攻击流程，通过这个案例去给大家揭开 Token 的神秘面纱

```
1.受害者登录a.com，并保留了登录凭证（Cookie）
2.攻击者引诱受害者访问了b.com
3.b.com 向 a.com 发送了一个请求：a.com/act=xx ，浏览器会默认携带a.com的Cookie
4.a.com接收到请求后，对请求进行验证，发现请求里带有受害者的凭证，误以为是受害者自己发送的请求
5.a.com以受害者的名义执行了act=xx
6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作
```

CSRF 为什么能够攻击成功？其本质原因是重要操作的所有参数都是可以被攻击者猜测到的,攻击者只有预测出 URL 的所有参数与参数值，才能成功地构造一个伪造的请求；反之，攻击者将无法攻击成功,出于这个原因，可以想到一个解决方案：把参数加密，或者使用一些随机数，从而让攻击者无法猜测到参数值

比如，一个删除操作的 URL 是：  
http://host/path/delete?username=abc&item=123  
把其中的 username 参数改成哈希值：  
http://host/path/delete?username=md5(salt+abc)&item=123

这样，在攻击者不知道 salt 的情况下，是无法构造出这个 URL 的，因此也就无从发起 CSRF 攻击了;而对于服务器来说，则可以从 Session 或 Cookie 中取得"username=abc"的值，再结合 salt 对整个请求进行验证，正常请求会被认为是合法的

但是这个方法也存在一些问题。首先，加密或混淆后的 URL 将变得非常难读，对用户非常不友好。其次，如果加密的参数每次都改变，则某些 URL 将无法再被用户收藏。最后，普通的参数如果也被加密或哈希，将会给数据分析工作带来很大的困扰，因为数据分析工作常常需要用到参数的明文

因此，我们需要一个更加通用的解决方案来帮助解决这个问题。这个方案就是使用 Token（现在大家知道 Token 怎么来的了吧），回到上面的 URL 中，保持原参数不变，新增一个参数 Token，这个 Token 的值是随机的，不可预测：

http://host/path/delete?username=abc&item=123&token= \[random (seed) \]

由于这个 Token 的存在，攻击者无法再构造出一个完整的 URL 去实施 CSRF 攻击了，所以说白了这个 CSRF 攻击之所以能够攻击成功，就是因为浏览器访问页面的时候，默认不知不觉的会带上 Cookie 的值，那防御的方法就是找到一个传输数据的容器，且这个容器不会被发包的时候不知不觉的自动带上，接下来给大家说一下这个 Token 应该放哪呢？

3.首先要明白 Token 本身还是要做验证比较的，而且 Token 和 Cookie 和 Session 是能同时存在的，完全也可以只用 Token 去做验证数据包的一致性，用 Cookie 或者是 Session 去验证身份，现在主流方式有三种吧

**第一种：CSRF Token（Token 同时放在表单和 Session 中）**

由于在 CSRF 攻击中，攻击者无法直接窃取到用户的信息，仅仅是冒用，那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token，服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击，步骤如下：

```
1. 将CSRF Token输出到页面中
首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，一般Token都包括随机字符串和时间戳的组合，至于服务器怎么给，在上面介绍Session的时候也讲到了三种具体的办法
```

```
2.页面提交的请求携带这个Token
对于GET请求，Token将附在URL之后，这样URL 就变成 http://url?csrftoken=tokenvalue ；或者放在请求头中：
```

![](image-20.png)

```
3.而对于 POST 请求来说，可以放在请求体或者请求头中
```

```
4.服务器验证Token是否正确
解密Token  ->  对比随机字符串以及时间戳，如果随机字符串一致且时间未过期，那么这个Token就是有效的
```

**第二种：双重 cookie 验证（Token 同时放在表单和 Cookie 中）**

（把这些带有信息的东西如果当作 Session 放在服务器上面，会给服务器带来很大的压力，验证信息储存于客户端中，不会给服务器带来压力）

1.由于单纯的 csrf 只能让请求中带有 cookie，但是并不能读取 cookie 加入到 POST 或 URL 中，因此前端在发送请求时可以读取 cookie 并将它加入到 url 或者请求体中

双重 Cookie 采用以下流程：

```
1.在用户访问网站页面时，服务器会向浏览器注入一个Cookie，内容为随机字符串（例如csrftoken=v8g9e4ksfhw）
2.在前端向后台发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrftoken=v8g9e4ksfhw）
3.后端收到请求后会验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝
```

不过此方法并没有大规模应用，其在大型网站上的安全性还是没有 CSRF Token 高

2.如果 Token 保存在 Cookie 中，而不是服务器端的 Session 中，一个用户打开几个相同的页面同时操作，当某个页面消耗掉 Token 后，其他页面的表单内保存的还是被消耗掉的那个 Token，因此其他页面的表单再次提交时，会出现 Token 错误，这个就与 Cookie 和 Session 本身的机制有关系了

```
将令牌存储在服务器端的Session中不会出现上述问题，因为服务器端的Session是针对每个用户的独立会话进行管理的，不同用户之间的Session是相互隔离的，因此不会共享Session数据。这与客户端Cookie不同，Cookie通常在同一域名下的所有页面之间共享，因此可能导致多个页面共享相同的令牌
```

**第三种：Local Storage**

将 Token 储存在 Local Storage 中然后通过请求中的 Authorization Header 发送，注意 Header 不是由浏览器自动添加，然后的话就是和上两点一样，验证的 Token 既能放在 Cookie 中，也能放在 Session 中，但这个方法从安全的角度来看，如果你的网站有着 XSS 漏洞那么黑客可以非常轻松（只需要一行代码）的读取你的 Local Storage 并窃取 Token

- **延伸-JWT**

  1.大家别把 JWT 和这个 Token 给搞混了，JWT 其实就是一种计算方式吧，如果不加任何的措施，它本身压根是防不了 CSRF 攻击的，那为什么还要用这个 JWT 呢？因为大家看我上面说的这些东西，或多或少都是要去用到服务器的资源的，都是要去比较的，而用这个 JWT 就只需要进行计算就可以了，第一速度上绝对是遥遥领先，第二不用占用服务器的资源（只用保存一个 Secret），我还是去做个比较吧

```
Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效
JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据
```

2.那这个咋去防御 CSRF 这种攻击呢，这里一般就不用 Session 去搞了，因为设计 JWT 最初的目的就是不去占用服务器的资源，一般目前的话就是把 JWT 放在 Cookie 或者是 Local Storage 中

首先先纠正一个错误：**Cookie 比 Local Storage 更安全？**

这种观点是不全面的，Local storage 有着与 Cookie 一样的安全机制，只有加了 httpOnly 和 secure 的 Cookie 才更加安全，对于普通的 Cookie，它的安全等级与 Local Storage 并无差别

**第一种：JWT 与 Local Storage**

优点：

```
1.在笔者看来在安全方面最大的收益便是天然的CSRF免疫，因为不会被浏览器自动发送。 如果你使用了这种方法，后端并不需要花费时间精力来做CSRF相关的防护
2.如果你JWT较大或者你并不是Cookie的唯一使用者，那么你会觉得放在Local Storage中更加方便，毕竟Cookie的4k大小很容易用完
3.JS可以直接读取JWT，方便使用
```

缺点：从安全的角度来看，如果你的网站有着 XSS 漏洞那么黑客可以非常轻松（只需要一行代码）的读取你的 Local Storage 并窃取 JWT

**第二种：JWT 与 Cookie(加了 httpOnly 和 secure)**

优点：

```
更加安全？黑客无法直接读取加了httpOnly Cookie中的内容，secure确保cookie只经由https传输
```

缺点：

```
1.Cookie 的4K存储空间太小
2.CSRF问题
```

那这么做有没有办法去防 CSRF 呢？还是有的，并且我们也在上文提到过这种思路，就是用双重 Cookie，或者是直接放到表单或参数里面，这样既可以防止 CSRF，也可以保证不占用服务器的资源，可以把 JWT 理解为，加上信息的 Token，但这个做法不太安全，目前很少这么搞的

- **结尾**

![](image-21.png)

哈哈哈哈大家听了木有，okok，那基本到这里就结束了，相信大家看完之后一定是收获满满的，大家一起加油！奥里给！！！