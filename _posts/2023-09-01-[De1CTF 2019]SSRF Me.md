---
layout: mypost
title: "[De1CTF 2019]SSRF Me"
categories: [ctf_wp]
---

1.这个题似曾相识，和上周打ctf的那道python的题有点类似，都应该是个python的类污染，上次那个确实有点小难，复现下来还是代码读懂，但里面的有些知识还是难以理解，先将下面的代码给格式化一下不然太看着ex

![](Screenshot_121-1024x160.png)

```
#! /usr/bin/env python
#encoding=utf-8
from flask import Flask
from flask import request
import socket
import hashlib
import urllib
import sys
import os
import json
reload(sys)
sys.setdefaultencoding('latin1')

app = Flask(__name__)

secert_key = os.urandom(16)


class Task:
    def __init__(self, action, param, sign, ip):
        self.action = action
        self.param = param
        self.sign = sign
        self.sandbox = md5(ip)
        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr
            os.mkdir(self.sandbox)

    def Exec(self):
        result = {}
        result['code'] = 500
        if (self.checkSign()):
            if "scan" in self.action:
                tmpfile = open("./%s/result.txt" % self.sandbox, 'w')
                resp = scan(self.param)
                if (resp == "Connection Timeout"):
                    result['data'] = resp
                else:
                    print resp
                    tmpfile.write(resp)
                    tmpfile.close()
                result['code'] = 200
            if "read" in self.action:
                f = open("./%s/result.txt" % self.sandbox, 'r')
                result['code'] = 200
                result['data'] = f.read()
            if result['code'] == 500:
                result['data'] = "Action Error"
        else:
            result['code'] = 500
            result['msg'] = "Sign Error"
        return result

    def checkSign(self):
        if (getSign(self.action, self.param) == self.sign):
            return True
        else:
            return False


#generate Sign For Action Scan.
@app.route("/geneSign", methods=['GET', 'POST'])
def geneSign():
    param = urllib.unquote(request.args.get("param", ""))
    action = "scan"
    return getSign(action, param)


@app.route('/De1ta',methods=['GET','POST'])
def challenge():
    action = urllib.unquote(request.cookies.get("action"))
    param = urllib.unquote(request.args.get("param", ""))
    sign = urllib.unquote(request.cookies.get("sign"))
    ip = request.remote_addr
    if(waf(param)):
        return "No Hacker!!!!"
    task = Task(action, param, sign, ip)
    return json.dumps(task.Exec())
@app.route('/')
def index():
    return open("code.txt","r").read()


def scan(param):
    socket.setdefaulttimeout(1)
    try:
        return urllib.urlopen(param).read()[:50]
    except:
        return "Connection Timeout"



def getSign(action, param):
    return hashlib.md5(secert_key + param + action).hexdigest()


def md5(content):
    return hashlib.md5(content).hexdigest()


def waf(param):
    check=param.strip().lower()
    if check.startswith("gopher") or check.startswith("file"):
        return True
    else:
        return False


if __name__ == '__main__':
    app.debug = False
    app.run(host='0.0.0.0')
```

基本和上回的格式差不多

2.这种题首先就是先看路由，包括任何框架类的源码白盒审计都是先看路由，很明显这里里面有三个路由

```
@app.route("/geneSign", methods=['GET', 'POST'])
@app.route('/De1ta',methods=['GET','POST'])
@app.route('/')（这个就是显示源码的，而源码就是藏在一个叫做code.txt的文件里面，这道题估计也是这思路，就是读取flag.txt就行，因为这道题目有提示，它就在这个里面）
```

首先就分析一下这个路由/geneSign

```
首先接收了一个我们传进去的参数param，然后定义了一个参数action，它的值是scan，接下来把这两个参数传给了函数getSign(action, param)，它的作用是返回 md5(secert_key + param + action)的值，这里的secert_key我们是不知道的，param是我们能控制的，action=scan，也可以很清楚能知道返回的结果，因为会回显的
```

再就是分析这个最复杂的路由/De1ta，应该也是解题的关键

定义了一个challenge()函数，通过cookie接受了两个参数action和sign，通过get方法得到param的值，这里的三个参数是可控的，然后把param参数通过waf()函数，而这个waf函数大概意思就是不可以用伪协议读取，它怕什么就来什么，所以这题大概率就是要读取flag.txt了，但这个就很奇怪，因为我都能读取这个框架的源码了，还不能读取flag.txt？除非单独给文件上了权限

```
def waf(param):
    check=param.strip().lower()
    if check.startswith("gopher") or check.startswith("file"):
        return True
    else:
        return False
```

最后就开始构造这个Task类，并执行方法

```
task = Task(action, param, sign, ip)
return json.dumps(task.Exec())
```

3.总结一下流程

- sign传给checkSign()函数def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False 需要满足md5(secert\_key + param + action)==sign

- 判断 参数action里有没有scan，有的话在上面创建的目录下创建一个result.txt ，然后通过scan()函数把名字为param的网址里的内容写到result.txt中，由于param是可控的，所以很容易想到这里把flag.txt传给param

- 判断 参数action里有没有read，若有，读取result.txt的内容赋值给result

4.这就相对容易了，虽然很长，但一步一步理解起来还是能做的

```
1.明确一点：路由/geneSign就是工具人，用以得到sign的值关键是路由/De1ta
2.想要读取flag先要满足checkSign()的条件：if (getSign(self.action, self.param) == self.sign):这三个参数都是我们传进去的
* 首先看左边：要想读取到flag，self.param肯定等于flag.txt。还要满足后面两个if的条件self.action要包含read和scan
* 然后看右边：后面的self.sign中的param是get得到的，action等于scan。
即：
3.md5(secert_key +flag.txt + action)=md5(secert_key +param + scan)
可见，要使上式成立，只要action=readscan，param=flag.txtread 即可
```

然后就写payload就行了，下面是结果，会以json的形式返回（代码就是这么写滴）

![](Screenshot_70-1024x522.png)

![](Screenshot_71-1024x623.png)

Finish!!!