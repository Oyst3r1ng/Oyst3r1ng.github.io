---
layout: mypost
title: "Windows 逆向-字符串相关操作"
categories: [Windows 逆向]
---

emmm这就是纯写代码的一篇文章，直接上代码了，前面课堂上的海东老师讲的我就直接CV了

## 课堂

### 返回字符串的长度

```C
#include "stdafx.h"

//因为我们要传进来一个字符串的变量名，而字符串变量名单独用表示地址，所以是char*
int strlen(char* s){   //s就表示传进来的字符数组变量的首地址
    int len = 0;
    while(*s != '\0'){   //*s表示取此时s存的地址中的值
        len++;
        s++;     //s的类型是char*,s++表示地址往后一位
    }
    return len;
}
int main(){
    char str[] = "china";
	int length = strlen(str);   //这里就是传str，str表示字符数组的首地址，所以类型为char*类型
    printf("%d",length);
    return 0;
}
```

### 字符串的复制

```C
#include "stdafx.h"

char* strcpy(char* dest,char* src){
	char* ret = dest;//因为最后要返回dest首地址,所以要先存到另一个变量里,不然下面的操作会影响dest的值
    while(*src){ //*src != '\0'可以省略,因为只要等于0就表示false,自然不会继续循环;其他的值都继续循环
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
    return ret;
}

int main(int argc,char* argv[]){
    //dest定义成什么样都无所谓，只要够存的下src中的数据就可以，因为在方法中最后只要src中的数据复制完就会	  添加'\0'
    char dest[] = "zjjsjsjsjsjsj";
    char src[] = "abcdefgh";
   	char* ret = strcpy(dest,src);   //返回类型为char*,存放的是新字符串的首地址
    printf("%s",ret);
	return 0;
}
```

### 字符串的拼接

```C
#include "stdafx.h"

char* strcat(char* dest,char* src){
    char* ret = dest;
    while(*dest){
        dest++;
    }   //找到dest字符串结尾，即'\0'的地址
    while(*src){
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
    return ret;
}

int main(int argc,char* argv){
    char str1[] = "abc";
    char str2[] = "defghi";
    printf("%s",strcat(str1,str2));
    return 0;
}
```

### 比较字符串是否相等

```C
#include "stdafx.h"

int strcmp(char* s1,char* s2){
    while(*s1){  //这里任意一个字符串结束了但是另一个还没有结束，那么结果都是1，所以随便用一个就行
        if(*s1 != *s2){
            return 1;  //不一样返回1
        }
        s1++;
        s2++;
    }
    return 0;  //一样返回0
}

int main(int argc,char* argv[]){
    char str1[] = "abcdef";
    char str2[] = "abcdef";
    printf("%d",strcmp(str1,str2));
    return 0;
}
```

### 指针函数

像上述这种返回值类型为指针类型的（带\*号类型），就是指针函数！！！，一定要与函数指针区分开，后面还会学数组指针和指针数组

## 作业

![](images/image-81.png)

WOW对应的ASCII码用十六进制表示依次为：0x57，0x4F，0x57（**这里要注意：基本数据类型int short等再内存中数据是反着存的，但是字符串在内存中从低地址到高地址就是字符串的顺序，不要和前面搞混了**）

![](images/Screenshot_3-1024x625.png)

```C
// 1207C.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

char data[100] = {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,					
	0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,					
	0x00,0x33,0x00,0x47,0x0C,0x0E,0x57,0x4F,0x57,0x11,					
	0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,					
	0x57,0x4F,0x57,0x10,0x00,0x00,0x00,0x00,0x00,0x00,					
	0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,					
	0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,					
	0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,					
	0x00,0x00,0x00,0x64,0x00,0x0F,0x57,0x4F,0x57,0x00,					
	0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00
};

int compare_arry(char* str1 ,char* str2){
	
	int judgment = 0;
	while (*str1 != '\0' && *str2 != '\0'){	
		if(*str1 == *str2){
			str1++;
			str2++;
		}else{
			return judgment;
		}
	}
	if(*(str1) == 0 && *(str2) == 0)
		judgment = 1;
	return judgment;
}


char* core_fuction(char* a ,char* b){
	
	for(int i=0;i<97;i++){
		
		char* flag = b;
		if(compare_arry(a,b)){
			return flag;
		}else{
			b++;
		}

	}
	return 0;
}

void fuction_2(char* data){

	char a[] = "WOW";
	
	for(int i=0;i<97;i++){
		
		char* temp_a = a;
		char* temp_data = data;

		if(compare_arry(temp_a,temp_data)){
			printf("%x\n",data);
		}
		data++;
	}
}
int main(int argc, char* argv[])
{
	char a[] = "WOW";
	
	char* result = core_fuction(a,data);
	printf("%x\n",result);
	printf("-------------------------------\n");
	fuction_2(data);
	return 0;

}
```