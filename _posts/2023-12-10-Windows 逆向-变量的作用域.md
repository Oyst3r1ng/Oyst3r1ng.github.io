---
layout: mypost
title: "Windows 逆向-变量的作用域"
categories: [Windows 逆向]
---

## 前言

这个在后面的内容中都会用到，了解这个有助于大家尽早的对程序有个清晰的认知

## 课堂

### 内存图

任何一个程序不是说在硬盘中就可以被CPU执行的，而是需要放到内存中，那么一个程序在使用内存时往往会被分为如下的几个区域

```
代码区：写的代码(语句，函数等)所存放的区域，包括汇编指令，这块区域里的数据是可读可写的

堆栈：参数，局部变量，临时数据所存放的区域

堆：动态申请的，且大小可变的数据所存放的区域，比如链表等，可读可写

全局变量区：定义的全局变量所存放的区域，可读可写

常量区：常量所在区域，只读！
```

以上每个区域的是否可读可写是相对于正向开发来说的，而对于逆向人员是可以做任意操作的。比如常量区对于正向程序员是只读的，但是如果逆向人员想要去修改去写入，是可以实现的：如果常量区这块内存不让写入，那么可以找到exe源文件，这些内存中的各个区域在exe源文件中都可以找到相应的位置，所以使用文本文件将exe打开找到常量区，去修改即可  

![](image-43-1024x821.png)

这种图以后大家会天天见到

### 全局变量和局部变量

#### 全局变量

定义在函数外的变量

```
#include "stdafx.h"
int i; //全局变量
int y;
int main(int argc, char* argv[]) 
{
	return 0;
}
```

全局变量的特点：

- **在程序编译完以后就已经分配了空间**，预留的大小由变量的数据类型决定，且位置不会发生变化即只要程序exe文件一执行，内存中就给全局变量分配了空间；直到exe文件退出运行后才会收回空间

- 全局变量如果没有给的初始值，默认为0

- 全局变量可以在任何其他的函数里面进行读、写

- 多个函数使用同一个全局变量,只要exe程序不结束，里面将一直存储最后一次修改的值

- **全局变量就是所谓的基址！！**（在程序执行时在内存中的地址固定下来）

- 全局变量的反汇编识别：

```
mov byte/word/dword ptr ds:[0x12345678],寄存器/数
只要是后面见到使用立即数直接寻址的多半都是全局变量
```

![](image-44.png)

由于num全局变量在exe加载时就已经分配了空间，所以在此函数调用时是看不到为num分配空间的过程的，但是由于函数中对全局变量进行了修改操作，那么可以发现，在寻找一块固定的内存地址，这一地址编号的内存就是全局变量num所在的内存位置（上图中可得num的地址为0x424a30）

#### 局部变量

定义在函数内部的变量

```
#include "stdafx.h"
void Function1(){
	int i = 10;	   //局部变量的定义、声明
	printf("%x",i);	  //局部变量的读
	i = 20;   //局部变量的写
}
```

它的一些特点：只有**当函数调用时**才会分配内存空间，且一定要赋初值，不然会得到垃圾数据，参数和局部变量只有在函数被调用时才会分配空间，调用结束后虽然还在堆栈中但已经是垃圾数据了，即分配的空间被回收了，局部变量的作用范围仅限于当前函数自己，其他函数无法使用，当函数执行完毕后，局部变量将变成垃圾数据，可以随时被其他数据所覆盖（联想堆栈图）

## 作业

无